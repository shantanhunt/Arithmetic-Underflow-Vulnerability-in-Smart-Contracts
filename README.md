# Arithmetic-Underflow-Vulnerability-in-Smart-Contracts

Letâ€™s say that you (i.e. msg.sender) have balances of 1000 and the contract to which this withdraw function belongs is holding 1 Million Wei(which is the smallest unit of Ether). When you will try to withdraw 800, the contract will check in the require statement whether your balances minus the amount (i.e. 1000 - 800 = 200) is greater  than 0 or not. In this case it is. So the contract will execute the rest of the code and transfer 800 wei to you. But again you call the withdraw function by setting the _amount parameter to 300. This will check the require statement again but now as the balances mapping has a value of unsigned integer which ranges from 0 to 2^256 - 1, balances[msg.sender] - amount will underflow and the result will be ...

## Steps to Implement an attack on Vulnerability
1) Set VALUE as 500000000 wei. 
2) Call sendEtherToSmartContract(). This will send 500000000 wei to the smart contract.
3) Switch to another address which contains 100 ether.
4) Call updateBalance() function by passing 1000 as the argument for amount. This means that the msg.sender should only be
  able to withdraw 1000 wei from the smart contract.
5) Call withdraw() by passing argument as 800. 
6) Call withdraw() by passing argument as 300. Arithmetic underflow occurs. You are able to withdraw all the ether from the smart contract.

